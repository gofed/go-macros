# Copyright (c) 2015-2018 Jakub Cajka <jcajka@redhat.com>,
#                         Jan Chaloupka <jchaloup@redhat.com>,
#                         Nicolas Mailhot <nim@fedoraproject.org>
# This file is distributed under the terms of GNU GPL license version 3, or
# any later version.

# This file contains macros for building projects in golang for packages
# with golang compiler or gcc-go compiler based on an architecture.
# Golang is primarly for primary architectures, gcc-go for secondary.
#
# This file provides only macros and must not use any other package except
# redhat-rpm-macros.

# Define arches for PA and SA
%golang_arches   %{ix86} x86_64 %{arm} aarch64 ppc64le s390x
%gccgo_arches    %{mips}
%go_arches       %{golang_arches} %{gccgo_arches}

# Where to set GOPATH for builds
%gopath          %{_datadir}/gocode

# Define go_compilers macro to signal go-compiler package is available
%go_compiler     1

# Sanitize a Go import path that can then serve as rpm package name
# Mandatory parameter: a Go import path
%gorpmname() %{lua:
local goname = rpm.expand("%1")
-- lowercase and end with '/'
goname       = string.lower(goname .. "/")
-- remove eventual protocol prefix
goname       = string.gsub(goname, "^http(s?)://",         "")
-- remove eventual .git suffix
goname       = string.gsub(goname, "%.git/*",              "")
-- remove eventual git. prefix
goname       = string.gsub(goname, "^git%.",              "")
-- add golang prefix
goname       = "golang-" .. goname
-- remove FQDN root (.com, .org, etc)
goname       = string.gsub(goname, "^([^/]+)%.([^%./]+)/", "%1/")
-- special-case x.y.z number-strings as that’s an exception in our naming
-- guidelines
repeat
  goname, i = string.gsub(goname, "(%d)%.(%d)",            "%1:%2")
until i == 0
-- replace various separators rpm does not like with -
goname       = string.gsub(goname, "[%._/%-]+",            "-")
-- because of the Azure sdk
goname       = string.gsub(goname, "%-for%-go%-",          "-")
-- Tokenize along - separators and remove duplicates to avoid
-- golang-foo-foo-bar-foo names
local result = ""
local tokens = {}
tokens["go"]     = true
for token in string.gmatch(goname, "[^%-]+") do
   if not tokens[token] then
      result = result .. "-" .. token
      tokens[token] = true
   end
end
-- reassemble the string, restore x.y.z runs, convert the vx.y.z
-- Go convention to x.y.z as prefered in rpm naming
result = string.gsub(result, "^-", "")
result = string.gsub(result, ":", ".")
-- some projects have a name that end up in a number, and *also* add release
-- numbers on top of it, keep a - prefix before version strings
result = string.gsub(result, "%-v([%.%d])", "-%1")
print(result)
}

# Map Go information to rpm metadata. This macro will compute default spec
# variable values.
#
# The following spec variable MUST be set before calling the macro:
#
#   goipath   the packaged Go project import path
#
# The following spec variables SHOULD be set before calling the macro:
#
#   forgeurl  the project url on the forge,
#             if it can not be deduced from goipath
#   Version   if applicable, set it with Version: <version>
#   tag       if applicable
#   commit    if applicable
#   date      if applicable (to override the mtime of the Source archive)
#
#  Use -z for multiple calls to the macro
#
# The macro will attempt to compute and set the following variables if they are
# not already set by the packager:
#
#   goname         an rpm-compatible package name derived from goipath
#   gosource       an URL that can be used as SourceX: value
#   gourl          an URL that can be used as URL: value
#
# It will delegate processing to the forgemeta macro for:
#
#   forgesource    an URL that can be used as SourceX: value
#   forgesetupargs the correct arguments to pass to %setup for this source
#                  used by %forgesetup and %forgeautosetup
#   archivename    the source archive filename, without extentions
#   archiveext     the source archive filename extensions, without leading dot
#   archiveurl     the url that can be used to download the source archive,
#                  without renaming
#   scm            the scm type, when packaging code snapshots: commits or tags
#
# If the macro is unable to parse your forgeurl value set at least archivename
# and archiveurl before calling it.
#
# Most of the computed variables are both overridable and optional. However,
# the macro WILL REDEFINE %{dist} when packaging a snapshot (commit or tag).
# The previous %{dist} value will be lost. Don’t call the macro if you don’t
# wish %{dist} to be changed.
#
# Optional parameters:
#   -z <number> suffix all the read and written variable names with <number>
#               for example read     goipath<number>, version<number>…
#                       and generate goname<number>, archiveurl<number>…
#               Usage is similar to the -b %%setup argument
#               The macro assumes that null or nil suffix is used for the primary
#               package source.
#   -s  Silently ignore problems in forgeurl, use it if it can be parsed,
#       ignore it otherwise.
#   -v  Be verbose and print every spec variable the macro sets.
#   -i  Print some info about the state of spec variables the macro may use or
#       set at the end of the processing.
%gometa(z:svi) %{expand:%{lua:
local suffix      = rpm.expand("%{?-z*}")
local verbose     = false
local informative = false
if (rpm.expand("%{?-v}") ~= "") then
  verbose         = true
end
if (rpm.expand("%{?-i}") ~= "") then
  informative     = true
end
-- Be explicit about the spec variables we’re setting
local function explicitset(rpmvar,value)
  rpm.define(rpmvar .. " " .. value)
  if verbose then
    rpm.expand("%{echo:Setting %%{" .. rpmvar .. "} = " .. value .. "}")
  end
end
-- Never ever stomp on a spec variable the packager already set
local function safeset(rpmvar,value)
  if (rpm.expand("%{?" .. rpmvar .. "}") == "") then
    explicitset(rpmvar,value)
  end
end
-- Convenience aliasing of no suffix and zero suffix of a list of rpm variables
local function zalias(rpmvars)
  if (suffix == "") or (suffix == "0") then
    for _, sfx in ipairs({{"","0"},{"0",""}}) do
      for _, rpmvar in ipairs(rpmvars) do
        local toalias = "%{?" .. rpmvar .. sfx[1] .. "}"
        if (rpm.expand(toalias) ~= "") then
          safeset(rpmvar .. sfx[2], toalias)
        end
      end
    end
  end
end
-- Echo the set rpm variables in a list, with suffix
local function echovars(rpmvars, suffix)
  for _, rpmvar in ipairs(rpmvars) do
    rpmvar = rpmvar .. suffix
    local header = string.sub("  " .. rpmvar .. ":                                               ",1,21)
    rpm.expand("%{?" .. rpmvar .. ":%{echo:" .. header .. "%{?" .. rpmvar .. "}}}")
  end
end
zalias({"forgeurl","goipath","goname","gourl","gosource"})
local goipath  = rpm.expand("%{?goipath"  .. suffix .. "}")
-- All the Go packaging automation relies on goipath being set
if (goipath == "") then
  local msg = "Please set the Go import path in the %%{goipath" .. suffix .. "} variable before calling %%gometa"
  if (suffix ~= "") then
    msg = msg .. " -z " .. suffix
  end
  rpm.expand("%{error:" .. msg .. "!}")
end
local forgeurl = rpm.expand("%{?forgeurl" .. suffix .. "}")
if (forgeurl ~= "") then
  safeset("gourl"    .. suffix, "%{forgeurl"        .. suffix .. "}")
else
  safeset("gourl"    .. suffix, "https://%{goipath" .. suffix .. "}")
  safeset("forgeurl" .. suffix, "%{gourl"           .. suffix .. "}")
end
print(rpm.expand("%forgemeta %{?-z} %{?-s} %{?-v} %{?-i}"))
if (rpm.expand("%{?forgesource" .. suffix .. "}") ~= "") then
  safeset("gosource" .. suffix, "%{forgesource" .. suffix .. "}")
else
  safeset("gosource" .. suffix, "%{gourl" .. suffix .. "}/%{archivename" .. suffix .. "}.%{archiveext" .. suffix .. "}")
end
safeset(  "goname"   .. suffix, "%gorpmname %{goipath" .. suffix .. "}")
zalias({"forgeurl","goipath","goname","gourl","gosource"})
-- Final spec variable summary if the macro was called with -i
if informative then
  rpm.expand("%{echo:Go-specific packaging variables}")
  echovars({"goipath","goname","gourl","gosource"}, suffix)
end}
BuildRequires: compiler(go-compiler)
ExclusiveArch: %{go_arches}
}
